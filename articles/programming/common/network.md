# “网络”那些事

## Concept

| abbr      | full  | description
| --        | --    | --
| `OSI`     | Open System Interconnection           | 开放式系统互联通信参考模型
| `CA`      | Certificate Authority                 | 证书颁发机构
| `IP`      | Internet Protocol                     | 网络传输协议
| `TCP`     | Transmission Control Protocol         | 传输控制协议
| `UDP`     | User Datagram Protocol                | 用户数据报协议
| `HTTP`    | Hyper Text Transfer Protocol          | 超文本传输协议
| `HTTPS`   | Hyper Text Transfer Protocol Secure   | 超文本安全传输协议
| `QUIC`    | Quick UDP Internet Connections        | 快速 `UDP` 网络连接协议

## `TCP/IP` 五层模型

1. 应用层 : `DNS`、`HTTP`、`HTTPS`、`RPC`、`P2P` (`DHCP`、`RTMP`、`GTP`)
    > `OSI` 七层模型中，将应用层细分为(应用层、表示层、会话层)
    * 表示层 : 
    * 会话层 : 
2. 传输层 : `TCP`、`UDP`、`QUIC`
3. 网络层 : (IP 层) `IP` (`ICMP`、`OSPF`、`BGP`、`IPSec`、`GRE`)
4. 链路层 : (MAC 层) `ARP`、`VLAN`、`STP`
5. 物理层 : 网络跳线

## `TCP` vs `UDP`
  
> `TCP` 特点
  
  * 可靠性 : 通过确认应答、超时重传等机制保证数据的可靠传输。
  * 有序性 : 通过数据序号来保证数据有序，传输完成后通过排序来保证数据的正确性。
  * 双全工 : 通信双方(服务端和客户端)都具备发送和接受数据的能力。(三次握手来保证)
  
> `UDP` 特点

  * 不可靠 : 通信通信双方不需要建立连接，不能保证数据准确送达。
  * 无序性 : 每次发送的数据包相互独立，没有特定的顺序。
  * 速度快 : 由于数据包结构简单，保证的 `UDP` 传输速度优于 `TCP`
  
  一些游戏、直播和需要低延迟实时性要求较高的应用，会使用 `UDP`。
  
> `TCP` 的 `keepalive` 机制

  `keepalive` 顾名思义是否还活着，是一种心跳检测机制。用于判断连接方是否还处于活动状态，以便断开已经失活连接释放资源。发送探测包后，如果处于活动状态，接收方会发送确认信号；如果处于失活状态，则会再连续再发送几次探测包如果均无响应则证明对方已断开连接，可以释放资源。
  
  需要注意的一点是，这个 `keepalive` 机制的时长一般默认为 2 小时。所以，不能使用使用该机制来确认实时性较高的保活探测。

## `HTTP` vs `HTTPS`

  `HTTP`: 是基于 `TCP/IP` 通信协议的一种数据传输协议。
  `HTTPS` : `= HTTP + SSL`，在 `HTTP` 协议的基础加上了加密处理。
  
> `HTTP` 常见报文

  | abbr    | full  | description
  | --      | --    | --
  | `SYN`   | synchronize   | 同步报文，用于建立连接
  | `ACK`   | acknowledge   | 确认报文，用于确认已接收
  | `FIN`   | finish        | 传输完成报文，用于结束连接
  | `RST`   | reset         | 重置报文，用于重置连接
  | `PSH`   | push          | 推送报文，用于直接将数据推送给接收端，而不是先放在缓存区
  | `URG`   | urgent        | 紧急报文，用于传输紧急数据，接收端会优先处理该数据
  
> “三次握手” - 创建连接
  * 客户端发给服务端 SYN 报文 => (服务端: 客户端的发送功能正常)
  * 服务端接受 SYN 报文之后，给客户端发送 SYN+ACK 报文 => (客户端: 服务端接受、发送功能正常)
  * 客户端收到 SYN+ACK 报文之后，给服务度发送 ACK 报文 => (服务单: 客户端接受功能正常)
  
  三次握手的核心点 : 开始数据通信前，确认双方发送和接受功能是否都正常。
  
> “四次挥手” - 断开连接
  * 一方完成数据发送发给另一方 FIN 报文 (一方: 数据传输完成)
  * 另一方接受 FIN 报文之后，给对方发送 ACK 报文 (另一方: 确认对方数据传输完成，并已关闭)
  * 另一方进行数据确认已完成，则也给对方发送 FIN 报文 (另一方: 如果有数据还未传输，传输完，保证数据传输完成。)
  * 对方收到 FIN 报文之后，回复 ACK 报文 (一方: 确认对方数据传输完成)
  
  四次挥手的核心点 : 断开连接前，确认双方数据均发送完毕。

> `HTTPS` 的加密过程原理

  首先需要了解两种加密模式，对称加密和非对称加密。
  * 对称加密：通信双方使用同一个密钥进行数据的加密和解密。
  * 非对称加密：有两个秘钥(私钥和公钥)，公钥用来加密数据，私钥用来解密。对称加密比非对称加密来说，因为使用单一秘钥计算量小，没有复杂的数学计算，所以效率上高于非对称加密。
  
  `HTTPS` 的连接过程也是三次握手。相对于 `HTTP` 的区别在于，第二次时服务器除了发送 `ACK` 之外，还会将加密的使用的公钥发送给客户端。第三次时客户端接受到公钥后，会校验公钥的合法性，并生产一个对称加密的秘钥。客户端回复服务端 `ACK` 的同时，也会将生成的秘钥通过公钥加密之后发送给服务端。之后双方就可以使用秘钥进行数据加密通信了。 

  `HTTPS` 中的中间人攻击，是指中间人先伪装成服务器接受客户端发送过来的请求，发送伪装的公钥给客户端。然后伪装成客户端将拦截的请求发送服务器，得到服务器的公钥。这样客户端以后发送请求都会请过中间人，中间人可以在篡改真实的请求。
  
  而为了解决中间人攻击这个问题，就引入了 `CA` 机构，用于给服务器签发数字证书。数字证书是包含服务器标识(如：域名)以及服务器公钥等信息。客户端可以通过这些信息来确认是否连接上正确的服务器，来避免中间人攻击。

## `HTTP` 各个版本的区别

  * `HTTP` 1.0 : 最早期版本，每次请求都会重新创建 `TCP` 的连接的创建和释放，造成极大的资源消耗。属于“非持续性连接”。
  * `HTTP` 1.1 : 改善了 1.0 版本的问题，修正为“持续性连接”。一次 `TCP` 连接可以发送多个请求和回复。引入 `pipeline` (管道)机制，可以同时发送多个请求，但是响应会按照请求队列的先后顺序进行，被称为“队头阻塞”问题。
  * `HTTP` 2.0 : 优化了传输数据格式(1.x 文本 -> 二进制)，减少了解析复杂度和提升传输速度。通过多路复用机制，解决了 1.0 “队头阻塞” 的问题，一次连接可以同时进行多个请求和响应。头信息压缩处理，减少数据体积。添加了服务器推送功能。
  * `HTTP` 3.0 : 开发中... `TCP` -> `QUIC`

## `HTTP` 中 `GET`、`POST` 区别

## `Cookie` vs `Session`

## `Socket`