# `thread` - “线程”那些事

## 进程与线程

  进程 : 程序的一次运行活动，各个进程之间相互资源独立。操作系统分配资源的基本单位，具有唯一的 PID 和 port 号。
  线程 : 线程是进程的最小执行单位，同一个进程内的多个线程共享进程内的资源。

## 进程间如何通信

## 最多能开辟多少个进程和线程？

## 解决线程安全的方案

  `CAS`(Compare And Swap) : 比较并交换，是一种实现原子的机制，可以保证一个变量在读、写时的原子性。
  基本原理是比较三个操作数，V (内存位置值)、A (原值)、B (新值)，比较 V 与 A，如果相等则将更新内存位置值交换为 B，如果不相等则不做交换操作。最后无论是否进行交换操作，都返回该位置的值。线程1 读取值后，在进行写时，将读取的值与要写入内存位置的值进行比较，这样如果线程2 在线程1 写之前修改了数据，那么比较的时候就会不相等，也就不能写入保证了原子性。
  
  `CAS` 会存在 `ABA` 问题。也就是说线程2 先将 A 修改为了 B，又将 B 修改为了 A，这样线程1 再进行比较时还是相等，但是其实数据已经是修改过了的。而解决 `ABA` 问题最常见的方案就是版本号，也就是每次修改数据时，都会加上一个版本号。原始版本号为 1，而线程1 读取数据时版本号为 1，当线程2 进行 `ABA` 数据修改后，版本号增长为了 3，则线程1 再进行比较时，就会知道 A 是修改后的了，也就不能写入。

## 协程与线程

  协程(Coroutine) : 也被称为“微线程”。运行在用户态，相比于线程具有极高的执行效率和极低的切换成本。

## OC 中为什么使用 `nonatomic` 而非 `atomic`？

## OC 中的 `atomic` 修饰符保证线程安全吗？

## 如何保证线程安全，与 `atomic` 有什么区别？

## 线程锁有哪些

- 读写锁(read/write-lock)
- 互斥锁(mutex-lock)
- 自旋锁(spin-lock)
- 递归锁(recursive-lock)

- 悲观锁
- 乐观锁

## 线程锁的底层实现?

## `async/await`

## 并行 vs 串行

  并行 (Concurrency) : 多个任务会同时执行。如果是多核 CPU 会是真正意义上并行，多个任务会在不同 CPU 上同时运行；如果是单核 CPU 是一种伪并行，是同一时间间隔上运行多个任务，CPU 在多个任务上切换运行，其实某一时刻上其实只有一个任务执行，由于 CPU 运行速度比较快，用户角度观察呈现并发状态。

## `GCD` vs `NSOperation`

  `NSOperation` 是对 `GCD` 的封装，对比 `GCD` 多了添加任务依赖、优先级设置的功能。
  
  `GCD` (Grand Central Dispatch) : 直译为大中央调度，是一种多线程并发解决方案。底层使用线程池来管理线程，屏蔽了程序创建线程的工作。只需要指定任务运行队列(串行或并行队列)，以及任务运行方式(同步或异步)。
  
  `GCD` 中的队列
   * 主队列 : 串行队列
   * 全局队列 : 并行队列
   * 自定义队列 : 串行或并行队列