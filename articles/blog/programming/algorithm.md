# “算法”那些事

## 算法知多少

| Algorithm | 说明
| -- | --
| traverse              | 遍历
| recursion             | 递归
| backtrace             | 回溯
| greedy                | 贪婪
| divide-conquer        | 分治
| sort                  | 排序
| search                | 搜索
| dynamic programming   | 动态规划

## 复杂度分析

- 最好时间复杂度
- 最坏时间复杂度
- 平均时间复杂度
- 摊还分析法 : 均摊时间复杂度，一种特殊的平均时间复杂度

## recursion - “递归”

  递归的本质就是使用栈的数据结构来进行问题求解。

> 可以进行递归求解的三要素？
 
  * 求解问题可以分解问子问题
  * 求解问题与子问题具有相同的求解思路
  * 存在递归终止条件
  
> 递归有哪些弊端？

  * 递归层数较深，会照成堆栈溢出
  * 递归过程中会存在重复计算
  * 空间复杂度高，函数调用耗时
  
> 尾递归

  尾递归是在进行递归代码编写时，将递归的调用操作作为函数的最后一个操作直接。 这个时候依赖编译器的“尾调用优化”(Tail Call Optimization) 会将递归代码优化为迭代代码。编译的优化的关键在于函数的最后一步就是递归调用，这个时候就不需要新开辟栈，直接将控制器和调用交个调用函数。
  
  尾递归的优化是编译器的特性，如果编程语言的编译器不支持“尾调用优化”，那么尾递归写法和常规递归也就没有区别了。

  尾递归的写法其实是一种自底向上的一种写法，使用的迭代的思维，需要将子问题的求解结果，从边界情况一直向上传递。从代码理解成面来讲，如果想要使用尾递归优化，还不如直接将递归代码转化为迭代代码清晰。并且尾递归的优化依赖编程语言的编译器，并不一定是百分百有效。

  ```swift
  // 斐波纳契 : 0,1,1,2,3,5,8
  //  f(n) = f(n-1) + fn(n-2)
  func fib(_ n: Int) -> Int {
      guard n > 1 else { return n }
      return f(n - 1) + f(n - 2)
  }
  // 尾递归优化
  func fibTail(_ n: Int, current: Int = 0, next: Int = 1) -> Int {
      guard n != 0 else { return current }
      return fibTail(n - 1, current: next, next: current + next)
  }
  // 迭代
  func fibTraverse(_ n: Int) -> Int {
      guard n > 1 else { return n }
      var pre = 0
      var current = 1
      for _ in 2...n {
           let next = pre + current
           pre = current
           current = next
      }
      return current
  }
  ```

## 排序算法

### 比较排序

> 交换排序
    
  * 冒泡排序
  * 快速排序
    
> 插入排序

  * 简单插入排序
  * 希尔排序

> 选择排序

  * 简单选择排序
  * 堆排序

> 归并排序

  * 二路归并排序
  * 多路归并排序

### 非比较排序

  * 桶排序
  * 计数排序
  * 基数排序

### 还有什么排序算法吗？

  * 猴子排序
  * 睡眠排序
  * 面条排序

## 搜素算法

> 顺序搜素

> 二分搜索

> 二叉搜索树


## 动态规划(Dynamic Programming)

动态规划的特点
  * 最优子结构 : 最优解是否可以通过子问题的最优解来计算得到，而子问题可以通过更小的最优解来得到。
  * 重叠子问题 : 解决每个子问题时，是否会遇到相同的子问题。可以使用缓存子问题结果(`DP` 表)，避免重复计算，提高算法效率。
  * 状态转移方程 : 当前状态是否可以使用子问题的状态描述。

动态规划求解方向
  * 自底向上 (`Bottom-Up`) : 迭代的方式解决问题
  * 自顶向下 (`Top-Down`) : 递归的方式解决问题

