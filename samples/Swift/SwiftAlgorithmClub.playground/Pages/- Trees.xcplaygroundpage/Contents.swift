//: [Previous](@previous)

//: ## Trees (树)
/*:
 * 遍历：
    - 中序遍历(深度遍历)
        + 先访问左子树
        + 再访问节点本身
        + 最后访问右子树
    - 前序遍历
        + 先访问节点本身
        + 再访问左子树
        + 最后访问右子树
    - 后序遍历
        + 先访问左子树
        + 再访问右子树
        + 最后访问节点本身
 */


//: Tree (树)
//: > 一种节点最多有两个孩子节点的树形结构

//: Binary Tree (二叉树)
//: > 以某种方式组织自己的节点的二叉树，以求较快的查询速度

//: Binary Search Tree (BST) (二叉搜索树)
//: > 一个特殊的二叉树(该树每个父节点最多有两个节点)，在插入和删除后总是保持顺序
/*:
 * 二叉树特点：
    - 左子节点 < 父节点
    - 右子节点 > 父节点
 * 插入：(时间复杂度：O(h) )
    - 与根节点比较，小于则走左分支，大于则走右分支
    - 继续操作，直到找到空节点插入
 * 查找：(时间复杂度：O(h) )
    - 小于当前值，取左边树
    - 大于当前值，取右边树
    - 等于当前值，找到！
 */


//: Red-Black Tree (红黑树)
//: > 自平衡二叉搜索树

//: Splay Tree (伸展树)
//: > 自平衡二叉搜索树允许快速检索最近更新的节点

//: Threaded Binary Tree (线索二叉树)
//: > 一种二叉搜索树通过额外的数据加快遍历并降低消耗

//: Segment Tree (线段树)
//: > 能够快速地对某区间进行计算

//: kd-Tree (kd 树)

//: Sparse Table (稀疏表)
//: > 又一个可以对数组部分做计算的数据结构，但是这次可以更快！

//: Heap (堆)
//: > 存储在一维数组中的二叉树，所以它不需要使用指针。很适合做为优先队列使用

//: Fibonacci Heap (斐波那契堆)

//: Trie (字典树)
//: > 一种特殊类型的树结构用来保存关联数据的结构

//: B-Tree (B 树)
//: > 自平衡搜索树，每个节点可以超过两个子节点

//: QuadTree (四叉树)
//: >


//: Octree (八叉树)


//: [Next](@next)
