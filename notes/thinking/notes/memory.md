# “内存”那些事

  “内存”顾名思义就是我们平常所说的电脑内存条。专业术语：随机存取存储器 `RAM`(Random Access Memory)。这个随机存取是重点，表明了存储器的特性，指定的是访问存储器的任意位置数据的时间周期都是恒定的。

## 存储器

| 访问方式 | 存储器
| -- | --
| 顺序存取(Sequential Access) | 这类存储器已经比较远古，磁带、黑胶唱片。
| 随机存取(Random Access) | 内存条 `RAM`(Random Access Memory)、磁盘存储器 `HDD`(Hard Disk Drive)、固态硬盘 `SSD` (Solid-State Drive)。

  顺序存取的介质，访问数据时都必须重头开始，所以访问速度是不如随机存储的存储器的。使用过的磁带的朋友应该很好理解这个过程，每次要听指定位置的歌曲，都必须重头开始不停快进才能定位指定位置。那说完顺序存取存储器，那接下来说说随机存取存储器的问题。

  大家都是随机存取(Random Access)为什么“内存”访问速度快？
    
  这些存储的访问速度的快慢就与存储数据介质材料和制造工艺有关。
  
| 存储器 | 制造工艺 | 工作原理
| -- | -- | --
| RAM | 半导体   | 通过改变电子状态来实现数据存储
| HDD | 磁性材料 | 通过磁头对磁盘的的磁性状态改变，来实现数据存储
| SSD | 晶体管   | 通过向晶体管加电，改变电荷数量来实现数据的存储

## 内存分区

  一个程序启动时，会被操作系统分配一块内存区域。程序运行过程中，又将得到的这块内存区域分为如下五个区域。其中代码区、常量区、全局/静态区大小在程序加载之后，大小不变。栈区和堆区的内存大小会根据程序运行过程中动态调整。

| 分区 | 说明
| -- | --
| 代码区       | 存放程序的二进制代码，这块区域在程序加载到内存中之后大小不变
| 常量区       | 程序定义的常量存储区域
| 全局/静态区   | 存放程序定义的全局和静态变量
| 栈区         | 由操作系统分配和管理，主要存储局部变量、函数参数等
| 堆区         | 由程序员手动申请和释放，如果管理不当会导致内存泄漏的问题

## 栈(stack) vs 堆(heap)

  内存中存在栈区和堆区，数据结构中存在栈和堆，那么这两者有什么关系？
  
  对于内存栈区来说，确实底层工作方式使用了栈的数据结构。遵循后进先出 `LIFO`(Last In First Out) 的原则。函数调用过程中，局部变量会被压入栈区，函数调用结束后，会从栈顶弹出。这也是栈区访问效率高于堆区的原因。
  
  而内存堆区，其实与堆这种数据结构就没有太大关系了。`heap` 在英语中表示一堆、许多的意思，表示一堆可以供程序员自由支配使用的内存区域。堆区的内存分配管理方案就与底层的操作系统以及所使用的编程语言有关了。使用的数据结构包括链表、位图、平衡二叉搜素树等。常用的内存分配算法：最佳适配算法、最差适配算法、首次适配算法、循环首次适配算法等。
  
  “栈溢出”：程序运行时，操作系统会分配一块固定大小的内存作为栈区。如果递归层数较多、申请临时变量过大等都可能触发栈溢出的问题。
  
  “内存不足”：堆区内存大小，是可以动态扩容的。但是这个大小也是有限，当程序发生内存泄漏，申请堆区内存不断增长，当达到操作系统设自动的内存阈值，就会触发内存不足的问题。

## 内存管理
  
  堆区的内存是由程序员申请使用，大多数现代编程语言为了提高编程效率，都实现了自动内存管理。而垃圾回收 `GC`(Garbage Collection)是自动内存管理中常使用的技术。

| 垃圾回收技术 | 说明
| -- | --
| 标记清除 (Mark - Sweep)       | 标记阶段遍历内存区域，标记对象的是否还存活；清除阶段，将已不在使用的内存区域回收清理。
| 引用计数 (Reference Counting) | 顾名思义，堆每块分配的内存区域对象设置一个计数器。每当引用一次该内存区域数据时，进行计数器 +1，不使用时进行 -1。当引用计数为 0 时表明该区域内存可以回收。引用计数会存在循环引用的问题。
| 分代回收 (Generational)       | 将内存划分为若干代(新生代、老年代)，经过多次垃圾回收仍然存活的对象会被移动到老年代区域。

| 编程语言 | 内存管理
| -- | --
| `C++`         | C++ 11 之后添加了智能指针，使用引用计数计数
| `Java`        | 分代垃圾回收技术
| `Python`      | 以引用计数为主，结合使用标记清除和分代回收技术
| `Swift`       | 自动引用计数 `ARC`(Automatic Reference Counting) 
| `JavaScript`  | 标记-清除(Mark Sweep)技术

## 内存对齐

  先说说数据的内存分布，基础的数据类型来说，`Int` 在 32 位机器上占用 4 字节，在 64 位机器上占用 8 个字节；`Float` 占用 4 个字节；`Double` 占用 8 字节；`Bool` 占用 1 字节；`String` 占用 16 字节。`struct` 结构体的内存占用与其包含的数据类型的占用有关系；`class` 是引用类型，所以内存占用就是指针内存占用，在 32位机器上占用 4 字节，64 位机器上占用 8 字节。
  
  还需要了解一个概念就是内存与 CPU 的交互。我们常说的 32 位、64位指的就是计算 CPU 的最大计算能力，也就是 CPU 上的寄存器的宽度。而 CPU 与内存交互调度的过程中，数据总线调度的最大宽度就是寄存器的这个宽度。为了提高 CPU 读取内存效率，最好在一个时钟周期内，读取数据的宽度刚好为这个宽度为最优。
  
  数据类型根据类型不同，占用的字节数可能存在不会刚好等于这个宽度。而“内存对齐”就是为了解决这个问题的。为了提高 CPU 读取内存效率，64 位机器来说，会将数据按照 8 字节的倍数进行对齐和排列，这样 CPU 在读取过程会，数据的起始地址都是 8 的倍数(例如 Float 类型数据只占用 4 个字节，后面会填充 4 个字节的空隙，后面再布局其它类型数据)。这样会照成一定的内存浪费，但是提高了 CPU 处理速度，是一种以空间换时间的优化方案。

## 内存泄漏

  对于计算机来说内存是有限了，程序使用内存时，如果申请了内存而未释放，这就会引起内存泄漏。通俗一点理解，将内存比如成一堆砖头，如果使用内存的码农都只借砖头，而不将砖头换回来，最后就会造成计算内存不足。

## `iOS` 中的内存管理

  `MRC`(Manual Reference Counting) : 手动引用计数。需要程序员自己申请(`retain`)和释放(`release`、`autorelease`)
  
  `ARC`(Automatic Reference Counting) : 自动引用计数，是 iOS 中的内存管理技术。编译器在编译阶段，在代码需要内存管理的地方插入内存管理操作(`retain`、`release`、`autorelase`)，当对象引用计数为 0 时，在 `dealloc` 的时候，会释放掉对象占用内存，自动地管理对象的生命周期。

  `autorelease` 用于延迟对象的释放。正常情况下，如果申请的对象超出作用域会释放。而使用 `autorelease` 的对象，会加入自动释放池中，延迟对象的释放时机。

### `autoreleasepool`

  自动释放池，`NSAutoreleasePool` 类，`ARC` 之后简化为 `OC` 中的 `@autoreleasepool`，`swift` 中的 `autoreleasepool`。通俗一点理解，就是使用 `autorelease` 的对象，会临时存放在这个池子里面，等到所在的线程的 `RunLoop` 一次循环结束时，会进行引用计数的 -1 操作。
  
  `autoreleasepool` 实现使用的数据结构：栈 + 双向链表。底层实现类为 `AutoreleasePoolPage`，这个是自动释放池的一页，创建时会存储双向链表的一个节点，剩下的空间设计为一个数据栈，用于存放加入自动释放池中的数据。
  对象加入自动释放池时，会调用 `Push` 函数，这个函数会返回一个地址 (这个地址很重要，是释放时 `Pop` 函数的入参，标记释放时的终点)。当着一页数据放满时，会新建一页，连接链表，新数据会继续存放在新创建的 `AutoreleasePoolPage` 的数据栈中。
  对象释放时，调用 `Pop` 函数，从栈顶开始释放对象，一直释放到 `Push` 函数标记的位置。如果释放完一页自动释放池中的全部对象，则根据链表向后一直释放，直到标记位置。

```objc
void * objc_autoreleasePoolPush(void) {
    return AutoreleasePoolPage::push();
}
void objc_autoreleasePoolPop(void *context) {
    AutoreleasePoolPage::pop(context);
}
```

### `RunLoop` 中什么时候释放内存

  首先翻译一下 `RunLoop` : 运行循环，从最基本编程语言语法层面来说就是一个循环 (`for`、`while`)。只不过这个循环结束条件，依赖于与这个 `RunLoop` 一一对应的线程，这个 `RunLoop` 循环结束的条件就是线程结束。而对于 `iOS` 程序来说，程序启动时会启动一个主 `RunLoop` 运行主线程，可以理解为一个死循环，程序结束时才会结束。

## Reference

- [Python 内存管理](https://docs.python.org/zh-cn/3/c-api/memory.html)
- [Swift 中的 ARC 机制: 从基础到进阶](https://juejin.cn/post/7094799538455576584)