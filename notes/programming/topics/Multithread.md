# Multithread
> 多线程

## Reference

- [怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473/answer/20851256)

## Concept

- 真正意义上的 异步IO 是说内核直接将数据拷贝至用户态的内存单元，再通知程序直接去读取数据。
- select / poll / epoll 都是同步IO的多路复用模式

- 同步和异步
    * 同步和异步关注的是消息通信机制
    * 所谓同步，就是在发出一个*调用*时，没得到结果之前，该*调用*就不返回。但是一旦调用返回就得到返回值了，*调用者*主动等待这个*调用*的结果
    * 所谓异步，就是在发出一个*调用*时，这个*调用*就直接返回了，不管返回有没有结果。当一个异步过程调用发出后，*被调用者*通过状态，来通知*调用者*，或者通过回调函数处理这个调用

- 阻塞和非阻塞
    * 阻塞和非阻塞关注的是程序在等待调用结果时的状态
    * 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才返回
    * 非阻塞调用是指在不能立即得到结果之前，该调用不会阻塞当前线程

- 经典故事

    > 老张爱喝茶，废话不说，煮开水。
    出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。
    1 老张把水壶放到火上，立等水开。（同步阻塞）
    老张觉得自己有点傻
    2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）
    老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。
    3 老张把响水壶放到火上，立等水开。（异步阻塞）
    老张觉得这样傻等意义不大
    4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）
    老张觉得自己聪明了。
    >
    > 所谓同步异步，只是对于水壶而言。
    普通水壶，同步；响水壶，异步。
    虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。
    同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。
    >
    > 所谓阻塞非阻塞，仅仅对于老张而言。
    立等的老张，阻塞；看电视的老张，非阻塞。
    情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。

- 进程 & 线程
    > 进程 : 一个运行的程序，分配独立的内存空间
    >
    > 线程 : 共享进程中的内存空间
    >
    > 死锁 : 当多个线程完成功能需要同时获取多个共享资源的时候可能会导致死锁

    * 哲学家就餐问题
    >
    > 5个哲学家吃中餐，坐在圆卓子旁。每人有5根筷子（不是5双），每两个人中间放一根，哲学家时而思考，时而进餐。每个人都需要一双筷子才能吃到东西，吃完后将筷子放回原处继续思考，如果每个人都立刻抓住自己左边的筷子，然后等待右边的筷子空出来，同时又不放下已经拿到的筷子，这样每个人都无法得到1双筷子，无法吃饭都会饿死，这种情况就会产生死锁：每个人都拥有其他人需要的资源，同时又等待其他人拥有的资源，并且每个人在获得所有需要的资源之前都不会放弃已经拥有的资源。

    * 线程的状态

    | 状态 | 说明
    | -- | --
    | 创建    | 新创建了一个线程对象。
    | 可运行  | 线程对象创建后，其他线程调用了该对象的`start()`方法。该状态的线程位于可运行线程池中，变得可运行，等待获取`CPU`的执行权。
    | 运行    | 就绪状态的线程获取了`CPU`执行权，执行程序代码。
    | 阻塞    | 阻塞状态是线程因为某种原因放弃`CPU`使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。
    | 死亡    | 线程执行完它的任务时。

- 线程队列
    * 串行队列，队列中的任务只会顺序执行
    * 并行队列，队列中的任务通常会并发执行
    * 队列使用
        + 串行队列，同步任务，不需要新建线程
        + 串行队列，异步任务，需要一个子线程
        + 并行队列，同步任务，不需要创建线程
        + 并行队列，异步任务，有多少个任务，就开N个线程执行