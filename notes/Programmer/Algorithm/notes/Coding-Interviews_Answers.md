> Coding Interviews: Questions, Analysis and Solutions (剑指Offer 2th) (68) 

## C++ & C# (3)

- **赋值运算函数** (1)

    > 如下为类型 CMyString 的声明，请为该类型添加赋值运算符函数

``` c++
class CMyString
{
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString(void);
    
private:
    char* m_pData;
};
```
 
- **实现 Singleton 模式** (2)

    > 设计一个类，我们只能生成该类的一个实例。

- **求 1+2+...+n** (64)

    > 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

## 数据结构 (45)

### 数组 (11)

- **数组中重复的数字** (3)
    
    * 找出数组中重复的数字
        
        > 在一个长度为 n 的数组里的所有数字都在 0~n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 {2,3,1,0,2,5,3}, 那么对应的输出是重复的数字 2 或者 3。
        
    * 不修改数组找出重复的数字
        
        > 在一个长度为 n+1 的数组里的所有数字都在 0~n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但是不能修改输入的数组。例如，如果输入长度为 8 的数组 {2,3,5,4,3,2,6,7}, 那么对应的输出是重复的数字 2 或者 3。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    | 1     | O(n)  | O(n)          | 哈希法，遍历数组，用一个 n 位数组(或哈希表)按角标 i 保存对应数
    | 2     | O(1)  | O(n*log n)    | 排序法，将数组排序之后比较前后两个数
    | 3     | O(1)  | O(n)          | 原地哈希法，遍历当前数组，比较角标 i 和当前数，如果相等则跳过；如果不相等，则与当前数相等的角标交换，直到当前角标 i 与交换后数相等，则进行下一次循环。
       

- **二维数组中的查找** (4)
    
    > 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    | 1 | O(1)  | O((i + j)/2)  | 使用 (row, column) 遍历二维数组，每次比较右上角元素；如果大于右上角元素，row++；如果小于右上角元素，column--


- **调整数组顺序使奇数位于偶数前面** (21)
    
    > 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    | 1 | O(n)  | O(n)  | 遍历数组，使用两个数组，分别保存奇数和偶数，然后赋值回原数组
    | 2 | O(1)  | 

- **顺时针打印矩阵** (29)

    > 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    | 1 | O(n)  | O(n)  | 根据二维数组的 (row, column) 边界，判断好遍历条件

- **数组中出现次数超过一半的数字** (39)

    > 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    | 1 | O(?)  | O(n)          | 哈希法，遍历数组，使用哈希表保存遍历数字的计数
    | 2 | O(1)  | O(n*log n)    | 排序法，先排好序，遍历统计每个数字的个数
    | 3 | O(1)  | O(2n)         | 计分法，使用 count 计分，number 为可能值，遍历数组，如果可能值与当前数相等 count++；如果不相等 count--；如果 count == 0，修改可能值为当前数；遍历完，最后剩下 count > 0 的可能数就有可能超过一半。再循环遍历一次数组统计可能数的个数。
    
- **数字序列中某一位的数字** (44)
    
    > 数字以 0123456789101112131415...的格式序列化一个字符序列中。在这个序列中，第 5 位(从 0 开始计数)是 5，第 13 位是 1，第 19 位是 4，等等。请写一个函数，求任意第 n 位对应的数字。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    | 1 | O(1)  | O(1)  | 转化为字符数组，按数组下标取值
    

- **把数组排成最小的数** (45)

    > 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    | 1 | O(n)  | O(1)  | 按照数组中的最长数补齐其它数，比较大小，按照从小到大合成最小数
    | 1 | O(?)  | O(?)  | 全排列

- **丑数** (49)

    > 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---

- **数组中的逆序对** (51)

    > 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---

- **数组中数字出现的次数** (56)
    
    * 数组中只出现一次的两个数字
        > 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度O(n)，空间复杂度O(1)。
    
    * 数组中唯一只出现一次的数字
        > 在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出哪个只出现一次的数字。
        
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
        
- **构建乘积数组** (66)

    > 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0] x A[1] x ... x A[i-1] x A[i+1] x ... x A[n-1]。不能使用除法。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---

### 字符串 (9)

- **替换空格** (5)

    > 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **正则表达式匹配** (19)

    > 请实现一个函数用来匹配包括'.'和'\*'的正则表达式。模式中的字符'.'表示任意一个字符，而'\*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab\*ac\*a"匹配，但是与"aa.a"和"ab\*a"均不匹配
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **表示数值的字符串** (20)
    
    > 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **字符串的排列** (38)

    > 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **把数字翻译成字符串** (46)
    
    > 给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成“a”，1翻译成“b”，……，11翻译成“1”,……，25翻译成“z”。一个数字可能有多个翻译。例如：12258有5种不同的翻译，分别是“bccfi”、“bwfi”、“bczi”、“mcfi”和“mzi”。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **最长不含重复字符的子字符串** (48)
    
    > 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含 'a'~'z' 的字符。例如，在字符串 "arabcacfr" 中，最长的不含重复的子字符串是 "acfr"，长度为4。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---

- **第一次只出现一次的字符** (50)
    
    * 字符串中第一个只出现一次的字符
        > 在一个字符串(1<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置
    
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---  
        
        
    * 字符流中第一个自出现一次的字符
        > 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---

- **翻转字符串** (58)
    
    * 翻转单词顺序
        > 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如，输入字符串“I am a student.”，则输出“student. a am I”。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        | 1 | O(n)  | O(n)  | 使用一个栈来保存遍历每一个字符，然后出栈赋值回原字符串
        | 2 | O(1)  | O(n/2)| 使用头尾指针往中间遍历交换，直到两个指针相遇   
        
    * 左旋转字符串
        > 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋操作的功能。例如，输入字符串“abcdefg”和数字2，该函数将返回左旋两位得到的结果“cdefgab”。
    
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
        
- **把字符串转换成整数** (67)

    > 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
### 链表 (8)

- **从尾到头打印链表** (6)

    > 输入一个链表，从尾到头打印链表每个节点的值。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **删除链表的节点** (18)
    
    * 在 O(1) 时间内删除链表节点
        > 给定单向链表的头指针和一个节点指针，定义一个函数在 O(1) 时间内删除该节点。
    
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 删除链表中重复的节点
        > 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
- **链表中倒数第 k 个节点** (22)
    
    > 输入一个链表，输出该链表中倒数第k个结点。为符合计数习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如：一个链表有6个节点，从头节点开始，它们的值一次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **链表中环的入口结点** (23)
    
    > 如果一个链表中包含环，请找出该链表的环的入口结点。例如：在1->2->3->4->5->6->3的链表中，包含一个环，环的入口节点是3。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **反转链表** (24)

    > 输入一个链表，反转链表后，输出反转链表的头结点。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---

- **合并两个排序链表** (25)

    > 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调递增规则。例如：链表1：1->3->5；链表2：2->4->6；合并后为：1->2->3->4->5->6。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **复杂链表的复制** (35)

    > 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **两个链表的第一个公共节点** (52)

    > 输入两个链表，找出它们的第一个公共结点。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
### 栈 & 队列 (4)

- **用两个栈实现队列** (9)

    > 用两个栈来实现一个队列。实现该队列的两个函数appendTail和deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。队列中的元素为int类型。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **包含 min 函数的栈** (30)
    
    > 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。在该栈中，调用min、push以及pop的时间复杂度都是O(1)。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **栈的压入、弹出序列** (31)

    > 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **队列的最大值** (59)
    
    * 滑动窗口的最大值
        > 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
        例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 队列的最大值
        > 请定义一个队列并实现函数 max 得到队列里的最大值，要求函数 max、push_back 和 pop_front 的时间复杂度都是 O(1)。

        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
        
### 树 (13)

- **重建二叉树** (7)

    > 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **二叉树的下一个结点** (8)
    
    > 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---

- **树的子结构** (26)

    > 输入两棵二叉树A，B，判断B是不是A的子结构。

    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---

- **二叉树的镜像** (27)
    
    > 操作给定的二叉树，将其变换为源二叉树的镜像。
    输入描述:
    二叉树的镜像定义:
    源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9  11
    镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
       11  9 7  5
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **对称的二叉树** (28)

    > 请实现一个函数，用来判断一棵二叉树是不是对称的。如果二叉树和它的镜像一样，那么它是对称的。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **从上到下打印二叉树** (32)
    
    * 不分行从上到下打印二叉树
        > 从上倒下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 分行从上到下打印二叉树
        > 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 之字形打印二叉树
        > 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
- **二叉搜索树的后序遍历序列** (33)
    
    > 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。例如，输入数组{5,7,6,9,11,10,8}，则返回true，因为这个整数序列是可以展开为一二叉搜索树的后序遍历结果。如果输入的数组是{7,4,6,5}，则由于没有哪棵二叉搜索树的后序遍历结果是这个序列，因此返回false。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **二叉树中和为某一值的路径** (34)

    > 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **二叉搜索树与双向链表** (36)

    > 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **序列化二叉树** (37)
    
    > 请实现两个函数，分别用来序列化和反序列化二叉树
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **二叉搜索树的第 k 大节点** (54)

    > 给定一颗二叉搜索树，请找出其中的第k大的结点。
    例如， 
             5 
            / \ 
           3   7 
          /\   /\ 
         2  4 6  8 
     中，按结点数值大小顺序第三个结点的值为4。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **二叉树的深度** (55)
    
    * 二叉树的深度
        > 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 平衡二叉树
        > 输入一棵二叉树，判断该二叉树是否是平衡二叉树。如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
- **数中两个节点的最低公共祖先** (68)

    > 输入两个树节点，求他们的最低公共祖先。
    
    * 二叉树（二叉搜索树）：二叉搜索树是排序的，如果当前节点大于两个节点的值，去左子树中寻找；如果当前节点小于两个节点的值，去右子树中寻找；如果当前节点位于两个节点值之间，则该节点就是要寻找的最低公共祖先。
    * 普通树（存在指向父节点的指针）：从给定节点出发，由父节点指针回到到根结点，形成链表。从而将问题转化为求两个链表的第一个公共节点的问题。
    * 普通树（不存在指向父节点的指针）：利用两个辅助链表通过递归遍历的方法找到两条到达给定节点的路径，寻找两个链表最后一个公共节点，就是最低公共祖先。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
## 算法 & 数据操作 (20)

### 递归 & 循环 (5)

- **斐波那契数列**（10）
    
    * 求斐波那契数列的第 n 项
        > 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 青蛙跳台阶

        > 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 变态跳台阶

        > 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 矩形覆盖

        > 我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。问用8个2x1的小矩阵无重叠地覆盖一个2x8的大矩阵，共有多少种方法？
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
- **数值的整数次方** (16)

    > 实现函数 `double Power(double base, int exponent)`。求 base 的 exponent 次方。不得使用库函数，同时不需要考虑大数问题。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **打印从 1 到最大的 n 位数** (17)
    
    > 输入数字 n，按书序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出1、2、3 一直到最大 3 位数 999。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **n 个骰子的点数** (60)
    
    > 把n个骰子扔在地上，所有骰子朝上的一面的点数之和为s.输入n，打印出s的所有可能的值出现的概率。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **圆圈中最后剩下的数字** (62)
    
    > 0、1…n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
### 查找 & 排序 (7)

- **旋转数组的最小数字** (11)

    > 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **最小的 k 个数** (40)
    
    > 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **数据流中的中位数** (41)
    
    > 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **1 ~ n 整数中 1 出现的次数** (43)

    > 输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数。例如输入12,1~12这些整数中包含1的数字有1、10、11和12，1一共出现了5次。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **在排序数组中查找数字** (53)
    
    * 数字在排序数组中出现的次数
        > 统计一个数字在排序数组中出现的次数。例如，输入排序数组 {1,2,3,3,3,3,4,5} 和数字 3，由于 3 在这个数组中出现了 4 次，因此输出 4。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 0 ~ n-1 中缺失的数字
        > 一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0~n-1 之内。在范围 0~n-1 内的 n 个数字中有且只有一个数字不在改数组中，请找出这个数字。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 数组中数值和下标相等的元素
        > 假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数，找出数组中任意一个数值等于其下标的元素。例如，在数组 {-3, -1, 1, 3, 5} 中，数字 3 和他们下标相等。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
- **和为 s 的数字** (57)
    
    * 和为 s 的两个数字
        > 输入一个递增排序的数组和一个数字，在数组中查找两个数，使得他们的和正好是s，如果有多对数字的和等于s，则输出任意一对即可。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
    * 和为 s 的连续正数序列
        > 输入一个正数s，输出所有和为s的连续正数序列（至少含有两个数）。
        
        | 解法 | 空间复杂度 | 时间复杂度 | 思路
        | --- | --- | --- | ---
        
- **扑克牌中的顺子** (61)
    
    > 从扑克牌中随机抽取5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
### 回溯法 (2) 

- **矩阵中的路径** (12)
    
    > 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **机器儿的运动范围** (13)
    
    > 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够达到多少个格子？例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
### 动态规划 & 贪婪算法 (4)

- **剪绳子**(14)

    > 给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n>1并且m>1)每段绳子的长度记为 k[0],k[1],...,k[m]。请问 k[0] x k[1] x ... x k[m] 可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **连续子数组的最大和**(42)

    > 输入一个整型数组，数组里有整数也有负数。数组汇总的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。例如输入的数组为{1,-2,3,10,-4,7,2,-5}，和最大的子数组为{3,10,-4,7,2}，输出为该子数组的和18。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **礼物的最大价值** (47)

    > 在一个m*n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格，知道到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿多少价值的礼物？
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **股票的最大利润** (63)
    
    > 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可获得的最大利润是多少？
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
### 位运算 (2)

- **二进制中 1 的个数** (15)

    > 请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有2位是1。因此如果输入9，则该函数输出2。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---
    
- **不用加减乘除做加法** (65)
    
    > 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
    
    | 解法 | 空间复杂度 | 时间复杂度 | 思路
    | --- | --- | --- | ---














