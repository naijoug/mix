> Cracking the Coding Interviews (150)

## 1 数组与字符串 (8)

- 1.1 确定字符互异 
    
    > 实现一个算法，确定一个字符串的所有字符是否全都不同。假设不允许使用额外的数据结构，又该如何处理？

- 1.2 原串翻转
    
    > 用 C 或 C++ 实现`void reverse(char* str)`函数，即反转一个`null`结尾的字符串。

- 1.3 确定两串乱序同构

    > 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

- 1.4 空格替换
    
    > 编写一个方法，将字符串中的空格全部替换为"%20"。假设该字符串尾部有足够的空间存放新增字符，并且知道字符串的"真实"长度。(注：用 Java 实现的话，请使用字符数组实现，以便在数组上操作。)
    示例
    输入: "Mr John Smith"
    输出: "Mr%20John%20Smith"
    
- 1.5 基本字符串压缩
    
    > 利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串 "aabcccccaaa" 会变为 "a2b1c5a3"。若"压缩"后的字符串没有变短，则返回原先的字符串。

- 1.6 像素翻转

    > 给定一幅由 N x N 矩阵表示的图像，其中每个像素的大小为 4 字节，编写一个方法，将图像旋转90度。不占用额外内存空间能否做到？

- 1.7 清零行列 
    
    > 编写一个算法，若 M x N 矩阵中某个元素为0，则将其所在的行与列清零。

- 1.8 翻转子串 
    
    > 假定有一个方法`isSubstring`，可检查一个单词是否为其他字符串的子串。给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成，要求只能调用一次`isSubstring`。（比如，waterbottle是erbottlewat旋转后的字符串。）


## 2 链表 (7)

- 2.1 链表去重
    > 编写代码，移除未排序链表中的重复结点。
    进阶
    如果不得使用临时缓冲区，又该怎么解决？

- 2.2 链表中倒数第 k 个节点

    > 实现一个算法，找出单向链表中倒数第 k 个结点。

- 2.3 访问单个节点的删除

    > 实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。示例：
    输入: 单向链表a->b->c->d->e中的结点c
    结果: 不返回任何数据，但该链表变为a->b->d->e。
    
- 2.4 链表分割

    > 编写代码，以给定值 x 为基准将链表分割成两部分，所有小于 x 的结点排在大于或等于 x 的结点之前。

- 2.5 链式 A+B
    
    > 给定两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。
    示例
    输入: (7->1->6) + (5->9->2)，即 617 + 295
    输出: 2->1->9，即 912
    假设这些数位是正向存放的，请再做一遍。
    示例
    输入: (6->1->7) + (2->9->5)，即 617 + 295
    输出: 9->1->2，即 912

- 2.6 确定有环链表开头节点 
    
    > 给定一个有环链表，实现一个算法返回环路的开头结点。
    有环链表的定义
    在链表中某个结点的 next 元素指向在它前面出现过的结点，则表明该链表存在环路。
    示例
    输入: A->B->C->D->E->C（C结点出现了两次）
    输出: C

- 2.7 回文链表

    > 编写一个函数，检查链表是否为回文。


## 3 栈与队列 (7)

- 3.1 一个数组实现三个栈

    > 描述如何只用一个数组来实现三个栈。

- 3.2 含有 min 函数的栈

    > 请设计一个栈，除 pop 与 push 方法，还支持 min 方法，可返回栈元素中的最小值。pop、push 和 min 三个方法的时间复杂度必须为O(1)。

- 3.3 集合栈

    > 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构`SetOfStacks`，模拟这种行为。`SetOfStacks`应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，`SetOfStacks.push()`和`SetOfStacks.pop()`应该与普通栈的操作方法相同（也就是说，`pop()`返回的值，应该跟只有一个栈时的情况一样）。
    进阶
    实现一个`popAt(int index)`方法，根据指定的子栈，执行 pop 操作。

- 3.4 汉诺塔问题
    
    > 在经典问题汉诺塔中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：
    (1) 每次只能移动一个盘子
    (2) 盘子只能从柱子顶端滑出移到下一根柱子
    (3) 盘子只能叠在比它大的盘子上
    请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。

- 3.5 两个栈实现队列

    > 实现一个`MyQueue`类，该类用两个栈来实现一个队列。

- 3.6 双栈排序

    > 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：push、pop、peek 和 isEmpty。

- 3.7 猫狗收容所

    > 有家动物收容所只收容狗与猫，且严格遵守"先进先出"的原则。在收养该收容所的动物时，收养人只能收养所有动物中"最老"（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中"最老"的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如 enqueue、dequeueAny、dequeueDog 和 dequeueCat 等。允许使用 Java 内置的`LinkedList`数据结构。


## 4 树与图 (9)

- 4.1 二叉树平衡检查

    > 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。

- 4.2 有向路径检查

    > 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。

- 4.3 高度最小的 BST

    > 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。

- 4.4 输出单层结点

    > 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。

- 4.5 检查是否为 BST

    > 实现一个函数，检查一棵二叉树是否为二叉查找树。

- 4.6 寻找下一个结点

    > 设计一个算法，找出二叉查找树中指定结点的 "下一个" 结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。

- 4.7 最近公共祖先

    > 设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。

- 4.8 子树判断 
    
    > 你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断 T2 是否为 T1 的子树。
    如果 T1 有这么一个结点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树。也就是说，从结点 n 处把树砍断，得到的树与 T2 完全相同。

- 4.9 二叉树中和为某一值的路径

    > 给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。

## 5 位操作 (8)

- 5.1 二进制插入

    > 给定两个 32 位的整数 N 和 M，以及标识比特位置的 i 与 j。编写一个方法，将 M 插入 N，使得 M 从 N 的第 j 位开始，到第 i 位结束。假设从 j 位到 i 位足以容纳 M，也即若 M=10011，那么 j 和 i 之间至少可容纳 5 个位。例如，不可能出现 j = 3 和 i = 2 的情况，因为第 3 位和第 2 位之间放不下 M。
    示例
    输入: N = 10000000000, M = 10011, i = 2, j = 6
    输出: N = 10001001100

- 5.2 二进制小数

    > 给定一个介于 0 和 1 之间的实数(如 0.72)，类型为 double，打印它的二进制表示。如果该数字无法精确地用32位以内的二进制表示，则打印 "ERROR"。

- 5.3 最接近的数

    > 给定一个正整数，找出与其二进制表示中 1 的个数相同、且大小最接近的那两个数(一个略大，一个略小)。

- 5.4 解释代码`((n & (n-1)) == 0)`的具体含义

- 5.5 整数转化

    > 编写一个函数，确定需要改变几个位，才能将整数 A 转成整数 B。
    示例
    输入: 31, 14
    输出: 2

- 5.6 奇偶位交换

    > 编写程序，交换某个整数的奇数位和偶数位，使用指令越少越好(也就是说，位 0 与 位 1 交换，位 2 与位 3 交换，依次类推)。

- 5.7 找出缺失的整数

    > 数组 A 包含 0 到 n 的所有整数，但其中缺了一个。在这个问题中，只用一次操作无法取得数组 A 里某个整数的完整内容。此外数组 A 的元素皆以二进制表示，唯一可用的访问操作是 "从 A[i] 取出第 j 位数据"，该操作的时间复杂度为常数。请编写代码找出那个缺少的整数。你有办法在 O(n) 时间内完成吗?

- 5.8 像素设定

    > 有个单色屏幕存储在一个一维字节数组中，使得 8 个连续像素可以存放在一个字节里。屏幕宽度为 w，且 w 可被 8 整除 (即一个字节不会分布在两行上)，屏幕高度可由数组长度及屏幕宽度推算得出。请事先一个函数`drawHorizontalLine(byte[] screen, int width, int x1, int x2, int y)`，绘制从点 (x1, y) 到点 (x2, y) 的水平线。

## 6 智力题 (6)

- 6.1 有 20 瓶药丸，其中 19 瓶装有
- 6.2
- 6.3
- 6.4
- 6.5
- 6.6

## 7 数学 & 概率 (7)

- 7.1 

- 7.2 碰撞的蚂蚁
    
    > 类似问题: 在n个顶点的多边形上有n只蚂蚁，请求出这些蚂蚁发生碰撞的概率。

- 7.3 判断直线相交

    > 给定直角坐标系上的两条直线，确定这两条直线会不会相交。

- 7.4 加法运算替代

    > 请编写一个方法，实现整数的乘法、减法和除法运算(这里的除指整除)。只允许使用加号。

- 7.5 平分的直线

    > 在二维平面上，有两个正方形，请找出一条直线，能够将这两个正方形对半分。假定正方形的上下两条边与x轴平行。

- 7.6 穿点最多的直线

    > 在二维平面上，有一些点，请找出经过点数最多的那条线。

- 7.7 第 k 个数

    > 有一些数的素因子只有3、5、7，请设计一个算法，找出其中的第 k 个数。

## 8 面向对象设计 (10)

- 8.1
- 8.2
- 8.3
- 8.4
- 8.5
- 8.6
- 8.7
- 8.8
- 8.9
- 8.10

## 9 递归 & 动态规划 (11)

- 9.1 上楼梯

    > 有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶、3阶。请实现一个方法，计算小孩有多少种上楼的方式

- 9.2 机器人走方格 

    > 有一个 X x Y 的网格，一个机器人只能走格点且只能向右或向下走，要从左上角走到右下角。请设计一个算法，计算机器人从 (0,0) 到 (x,y) 有多少种走法?
    进阶
    假设有些店为 "禁区"，机器人不能踏足。设计一种算法，找出一条路径，让机器人从左上角移动到右下角。

- 9.3 魔术索引 

    > 在数组A[0..n-1]中，有所谓的魔术索引，满足条件 A[i]=i。给定一个升序数组，元素值各不相同，编写一个方法，在数组 A 中找出一个魔术索引，若存在的话。
    进阶
    如果数组元素有重复值，又该如何处理？

- 9.4 集合的子集

    > 请编写一个方法，返回某集合的所有非空子集。

- 9.5 字符串排序

    > 编写一个方法，确定某字符串的所有排列组合。

- 9.6 合法括号序列判断

    > 

- 9.7 

- 9.8 硬币表示

    > 给定数量不限的硬币，币值为25分、10分、5分和1分，请编写代码计算 n 分有几种表示法。

- 9.9 n 皇后问题

    > 

- 9.10 堆箱子 

    > 有一堆 n 个箱子，每个箱子宽wi，高hi，深di。 箱子不能翻转，将箱子堆起来，下面的箱子的宽度和长度必须大于上面的箱子。请实现一个方法，搭出最高的一堆箱子，箱堆的高度为每个箱子的高度的总和。

- 9.11 

## 10 扩展性 & 存储限制 (7)

- 10.1
- 10.2
- 10.3
- 10.4
- 10.5
- 10.6
- 10.7

## 11 排序 & 查找 (8)

- 11.1 

- 11.2 变位词排序

    > 

- 11.3 

- 11.4 

- 11.5 找出字符串

- 11.6 矩阵元素查找 

    > 有一个 N x M 的整数矩阵，矩阵的行和列都是从小到大有序的。请设计一个高效的查找算法，查找矩阵中元素x的位置。

- 11.7 叠罗汉

    > 

- 11.8 维护 x 的秩

## 12 测试 (6)

- 12.1
- 12.2
- 12.3
- 12.4
- 12.5
- 12.6

## 13 C & C++ (10)
 
 - 13.1
 - 13.2
 - 13.3
 - 13.4
 - 13.5
 - 13.6
 - 13.7
 - 13.8
 - 13.9
 - 13.10
 
## 14 Java (6)

- 14.1
- 14.2
- 14.3
- 14.4
- 14.5
- 14.6

## 15 数据库 (7)

- 15.1
- 15.2
- 15.3
- 15.4
- 15.5
- 15.6
- 15.7

## 16 线程 & 锁 (6)

- 16.1
- 16.2
- 16.3
- 16.4
- 16.5
- 16.6

## 17 中等难题 (14)

- 17.1 无缓存交换
    
    > 请编写一个函数，函数内不使用任何临时变量，直接交换两个数的值。
    
- 17.2 井字棋
    
    > 对于一个给定的井字棋棋盘，请设计一个高效算法判断当前玩家是否获胜。

- 17.3 阶乘尾零

    > 请设计一个算法，计算n的阶乘有多少个尾随零。

- 17.4 无判断 max

- 17.5 珠玑妙算

- 17.6 最小调整有序

- 17.7 数字发音

- 17.8 最大连续数列和

- 17.9 词频统计

- 17.10 
 
- 17.11 

- 17.12 整数对查找

- 17.13 树转链表

    > 

- 17.14 

## 18 高难度题 (13)

- 18.1 另类加法

    > 请编写一个函数，将两个数字相加。不得使用+或其他算数运算符。

- 18.2 

- 18.3 

- 18.4 2 的个数

    > 请编写一个方法，输出0到n(包括n)中数字2出现了几次。

- 18.5 单词最近距离

    > 有一篇文章内含多个单词，现给定两个单词，请设计一个高效算法，找出文中这两个单词的最短距离(即最少相隔的单词数,也就是两个单词在文章中位置的差的绝对值)。

- 18.6 

- 18.7 最长合成字符串

    > 有一组单词，请编写一个程序，在数组中找出由数组中字符串组成的最长的串A，即A是由其它单词组成的(可重复)最长的单词。

- 18.8 子串判断

    > 现有一个小写英文字母组成的字符串s和一个包含较短小写英文字符串的数组p，请设计一个高效算法，对于p中的每一个较短字符串，判断其是否为s的子串。

- 18.9 实时中位数

    > 现有一些随机生成的数字要将其依次传入，请设计一个高效算法，对于每次传入一个数字后，算出当前所有传入数字的中位数。(若传入了偶数个数字则令中位数为第n/2小的数字，n为已传入数字个数)。

- 18.10 字符串变换

    > 现有一个字典，同时给定字典中的两个字符串s和t，给定一个变换，每次可以改变字符串中的任意一个字符，请设计一个算法，计算由s变换到t所需的最少步数，同时需要满足在变换过程中的每个串都是字典中的串。

- 18.11 最大子方阵

    > 有一个方阵，其中每个单元(像素)非黑即白(非0即1)，请设计一个高效算法，找到四条边颜色相同的最大子方阵。

- 18.12 最大和子矩阵

    > 有一个正整数和负整数组成的NxN矩阵，请编写代码找出元素总和最大的子矩阵。请尝试使用一个高效算法。

- 18.13 最大字母矩阵
    
    > 有一个单词清单，请设计一个高效算法，计算由清单中单词组成的最大子矩阵，要求矩阵中的行和列都是清单中的单词。





